
/**
* Cmd+Shift+o         快速查找类
* Ctrl+6              列出当前文件所有方法
* Ctrl+Cmd+up         切换.h和.m
* Cmd+Shift+Y         显示/隐藏控制台
* Cmd+Ctrl+Left/Right 到上/下一次编辑的位置
* Cmd+T               新建tab栏
* Cmd+Shift+[         切换tab栏
* ESC                 代码补全
*/


/**
* nil：指向一个对象的空指针,对Objective-C id 对象赋空值.
* Nil：指向一个类的空指针,表示对类进行赋空值.
* NULL：指向其他类型（如：基本类型、C类型）的空指针, 用于对非对象指针赋空值.
* NSNull：在集合对象中，表示空值的对象.
*/

/**
cmd + option + /
注释快捷键
@param collectionView <#collectionView description#>
@param indexPath <#indexPath description#>
*/


/**
*  isKindOfClass:确定一个对象是否是一个类的成员,或者是其子类的成员
*  isMemberOfClass:确定一个对象是否是当前类的成员
*  isSubclassOfClass：判断对象是否为某类或者其派生类的实例（类方法)
*/


/**
 * __block的作用:
 * 将其修饰的变量从栈区深拷贝到了堆区,对其指针地址的打印可以看出
 */

/**
* 浅拷贝:拷贝原对象指针,使其引用计数+1,并没有创建新对象.(AB指向同一块内存)
* 深拷贝:拷贝原对象的值,内存地址完全不同的新对象,两者无关联.
*/


/**
* 连线UI控件都用weak修饰
* NSString: 用copy修饰
* Block:    用copy修饰
* delegate: 用weak修饰
* retain(mrc),strong(arc),weak(arc，释放后赋值nil),assign(mrc,arc，释放后不会赋值nil，会导致野指针),copy(mrc,arc)
*/


/**
  strong和copy的区别
  使用strong只会增加引用计数。但是copy修饰的属性在setter方法中会执行一次拷贝（浅拷贝或深拷贝）

* NSString,NSArray,NSDictionary: 用copy修饰,防止值和类型被意外修改
* NSMutableString,NSMutableArray,NSMutableDictionay: 用strong修饰,防止类型被修改，从而造成crash
*

*/

/**
* command+= :siziToFit
* option+command+= :storyboard警告
*/

/** cell复用 UI绑定数据 */
+ (void)load
{
//编译的时候调用
}

+ (void)initialize
{
//创建实例的时候调用
}

//extern:代表其他类可以引用,如果不想让其它类访问，加static修饰
//const:不可更改
//static:静态/全局变量
extern NSString *const MJPropertyTypeIvar;


/**
    static
* 修饰局部变量：只会初始化一次，只有一份内存，不可以改变局部变量的作用域，可延长局部变量的生命周期。
* 修饰全局变量：作用域仅限于当前文件，
*/

/**
 * - (instancetype)init
 * - (instancetype)initWithFrame:(CGRect)frame
 * 自定义视图时,init会自动调用initWithFrame,所以只重写initWithFrame即可,两者都重写会造成加载多次
 */

/**
 * - (instancetype)initWithCoder:(NSCoder *)aDecoder
 * - (void)awakeFromNib 已经加载完成,可在里面初始化其它属性
 * 从storyboard或xib自定义视图时,先调用initWithCoder完成自身的初始化,加载完成后调用awakeFromNib
 */
 
 
 /** main之前都做了什么？
 * 系统先读取App的可执行文件(Mach-O文件)，从里面获得dyld的路径，然后加载dyld,dyld去初始化运行环境
 * 开启缓存策略，加载程序相关依赖库(其中也包含我们的可执行文件)，并对这些库进行链接，最后调用每个依赖库的初始化方法，在这一步，runtime被初始化
 * 从storyboard或xib自定义视图时,先调用initWithCoder完成自身的初始化,加载完成后调用awakeFromNib
 * 当所有依赖库的初始化后，轮到最后一位(程序可执行文件)进行初始化，在这时runtime会对项目中所有类进行类机构初始化，然后调用所有的load方法。最后dyld返回main函数地址，main函数被调用，我们便来到程序入口main函数
 */
 
 
 /**
     UIView和CALayer
  * 1. 首先UIView可以响应事件，Layer不可以;
  * 2. UIView是CALayer的delegate,当其属性改变、动画产生时，View能够得到通知;
  * 3. UIView主要处理事件，CALayer负责绘制
  */

/**
   @synthesize和@dynamic
* @synthesize:如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法,默认的就是 @syntheszie var = _var;
* @dynamic:告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成
*/

objc在向一个对象发送消息时，发生了什么？
根据对象的isa指针找到类对象id，在查询类对象里面的methodLists方法函数列表，如果没有在好到，在沿着superClass,寻找父类，再在父类methodLists方法列表里面查询，最终找到SEL,根据id和SEL确认IMP（指针函数）,在发送消息；

/**
   .a和framework
* .a本身只是二进制文件，需要配上.h和资源文件才能使用;
* .framework本身已经包含了二进制文件、.h和资源文件，可以直接使用;
*/


 所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中，在当前runloop结束时被释放。
}
